/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const BPF_LD: ::std::os::raw::c_uint = 0;
pub const BPF_LDX: ::std::os::raw::c_uint = 1;
pub const BPF_ST: ::std::os::raw::c_uint = 2;
pub const BPF_STX: ::std::os::raw::c_uint = 3;
pub const BPF_ALU: ::std::os::raw::c_uint = 4;
pub const BPF_JMP: ::std::os::raw::c_uint = 5;
pub const BPF_RET: ::std::os::raw::c_uint = 6;
pub const BPF_MISC: ::std::os::raw::c_uint = 7;
pub const BPF_W: ::std::os::raw::c_uint = 0;
pub const BPF_H: ::std::os::raw::c_uint = 8;
pub const BPF_B: ::std::os::raw::c_uint = 16;
pub const BPF_IMM: ::std::os::raw::c_uint = 0;
pub const BPF_ABS: ::std::os::raw::c_uint = 32;
pub const BPF_IND: ::std::os::raw::c_uint = 64;
pub const BPF_MEM: ::std::os::raw::c_uint = 96;
pub const BPF_LEN: ::std::os::raw::c_uint = 128;
pub const BPF_MSH: ::std::os::raw::c_uint = 160;
pub const BPF_ADD: ::std::os::raw::c_uint = 0;
pub const BPF_SUB: ::std::os::raw::c_uint = 16;
pub const BPF_MUL: ::std::os::raw::c_uint = 32;
pub const BPF_DIV: ::std::os::raw::c_uint = 48;
pub const BPF_OR: ::std::os::raw::c_uint = 64;
pub const BPF_AND: ::std::os::raw::c_uint = 80;
pub const BPF_LSH: ::std::os::raw::c_uint = 96;
pub const BPF_RSH: ::std::os::raw::c_uint = 112;
pub const BPF_NEG: ::std::os::raw::c_uint = 128;
pub const BPF_MOD: ::std::os::raw::c_uint = 144;
pub const BPF_XOR: ::std::os::raw::c_uint = 160;
pub const BPF_JA: ::std::os::raw::c_uint = 0;
pub const BPF_JEQ: ::std::os::raw::c_uint = 16;
pub const BPF_JGT: ::std::os::raw::c_uint = 32;
pub const BPF_JGE: ::std::os::raw::c_uint = 48;
pub const BPF_JSET: ::std::os::raw::c_uint = 64;
pub const BPF_K: ::std::os::raw::c_uint = 0;
pub const BPF_X: ::std::os::raw::c_uint = 8;
pub const BPF_MAXINSNS: ::std::os::raw::c_uint = 4096;
pub const BPF_ALU64: ::std::os::raw::c_uint = 7;
pub const BPF_DW: ::std::os::raw::c_uint = 24;
pub const BPF_XADD: ::std::os::raw::c_uint = 192;
pub const BPF_MOV: ::std::os::raw::c_uint = 176;
pub const BPF_ARSH: ::std::os::raw::c_uint = 192;
pub const BPF_END: ::std::os::raw::c_uint = 208;
pub const BPF_TO_LE: ::std::os::raw::c_uint = 0;
pub const BPF_TO_BE: ::std::os::raw::c_uint = 8;
pub const BPF_FROM_LE: ::std::os::raw::c_uint = 0;
pub const BPF_FROM_BE: ::std::os::raw::c_uint = 8;
pub const BPF_JNE: ::std::os::raw::c_uint = 80;
pub const BPF_JSGT: ::std::os::raw::c_uint = 96;
pub const BPF_JSGE: ::std::os::raw::c_uint = 112;
pub const BPF_CALL: ::std::os::raw::c_uint = 128;
pub const BPF_EXIT: ::std::os::raw::c_uint = 144;
pub const BPF_F_ALLOW_OVERRIDE: ::std::os::raw::c_uint = 1;
pub const BPF_PSEUDO_MAP_FD: ::std::os::raw::c_uint = 1;
pub const BPF_ANY: ::std::os::raw::c_uint = 0;
pub const BPF_NOEXIST: ::std::os::raw::c_uint = 1;
pub const BPF_EXIST: ::std::os::raw::c_uint = 2;
pub const BPF_F_NO_PREALLOC: ::std::os::raw::c_uint = 1;
pub const BPF_F_NO_COMMON_LRU: ::std::os::raw::c_uint = 2;
pub const BPF_F_RECOMPUTE_CSUM: ::std::os::raw::c_uint = 1;
pub const BPF_F_INVALIDATE_HASH: ::std::os::raw::c_uint = 2;
pub const BPF_F_HDR_FIELD_MASK: ::std::os::raw::c_uint = 15;
pub const BPF_F_PSEUDO_HDR: ::std::os::raw::c_uint = 16;
pub const BPF_F_MARK_MANGLED_0: ::std::os::raw::c_uint = 32;
pub const BPF_F_INGRESS: ::std::os::raw::c_uint = 1;
pub const BPF_F_TUNINFO_IPV6: ::std::os::raw::c_uint = 1;
pub const BPF_F_SKIP_FIELD_MASK: ::std::os::raw::c_uint = 255;
pub const BPF_F_USER_STACK: ::std::os::raw::c_uint = 256;
pub const BPF_F_FAST_STACK_CMP: ::std::os::raw::c_uint = 512;
pub const BPF_F_REUSE_STACKID: ::std::os::raw::c_uint = 1024;
pub const BPF_F_ZERO_CSUM_TX: ::std::os::raw::c_uint = 2;
pub const BPF_F_DONT_FRAGMENT: ::std::os::raw::c_uint = 4;
pub const BPF_F_INDEX_MASK: ::std::os::raw::c_uint = 4294967295;
pub const BPF_F_CURRENT_CPU: ::std::os::raw::c_uint = 4294967295;
pub const BPF_F_CTXLEN_MASK: ::std::os::raw::c_ulonglong = 4503595332403200;
pub const XDP_PACKET_HEADROOM: ::std::os::raw::c_uint = 256;
pub const BPF_LOG_BUF_SIZE: ::std::os::raw::c_uint = 65536;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub const BPF_REG_0: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_0;
pub const BPF_REG_1: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_1;
pub const BPF_REG_2: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_2;
pub const BPF_REG_3: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_3;
pub const BPF_REG_4: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_4;
pub const BPF_REG_5: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_5;
pub const BPF_REG_6: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_6;
pub const BPF_REG_7: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_7;
pub const BPF_REG_8: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_8;
pub const BPF_REG_9: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_9;
pub const BPF_REG_10: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_10;
pub const __MAX_BPF_REG: _bindgen_ty_1 = _bindgen_ty_1::__MAX_BPF_REG;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    BPF_REG_0 = 0,
    BPF_REG_1 = 1,
    BPF_REG_2 = 2,
    BPF_REG_3 = 3,
    BPF_REG_4 = 4,
    BPF_REG_5 = 5,
    BPF_REG_6 = 6,
    BPF_REG_7 = 7,
    BPF_REG_8 = 8,
    BPF_REG_9 = 9,
    BPF_REG_10 = 10,
    __MAX_BPF_REG = 11,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_insn {
    pub code: __u8,
    pub _bitfield_1: u8,
    pub off: __s16,
    pub imm: __s32,
}
#[test]
fn bindgen_test_layout_bpf_insn() {
    assert_eq!(::std::mem::size_of::<bpf_insn>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bpf_insn ) ));
    assert_eq! (::std::mem::align_of::<bpf_insn>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_insn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . code as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . off as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . imm as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( imm ) ));
}
impl Clone for bpf_insn {
    fn clone(&self) -> Self { *self }
}
impl bpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> __u8 {
        let mask = 15usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: __u8) {
        let mask = 15usize as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn src_reg(&self) -> __u8 {
        let mask = 240usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: __u8) {
        let mask = 240usize as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(dst_reg: __u8, src_reg: __u8) -> u8 {
        let bitfield_unit_val =
            {
                let bitfield_unit_val = { 0 };
                let dst_reg = dst_reg as u8 as u8;
                let mask = 15usize as u8;
                let dst_reg = (dst_reg << 0usize) & mask;
                bitfield_unit_val | dst_reg
            };
        let src_reg = src_reg as u8 as u8;
        let mask = 240usize as u8;
        let src_reg = (src_reg << 4usize) & mask;
        bitfield_unit_val | src_reg
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_cmd {
    BPF_MAP_CREATE = 0,
    BPF_MAP_LOOKUP_ELEM = 1,
    BPF_MAP_UPDATE_ELEM = 2,
    BPF_MAP_DELETE_ELEM = 3,
    BPF_MAP_GET_NEXT_KEY = 4,
    BPF_PROG_LOAD = 5,
    BPF_OBJ_PIN = 6,
    BPF_OBJ_GET = 7,
    BPF_PROG_ATTACH = 8,
    BPF_PROG_DETACH = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_map_type {
    BPF_MAP_TYPE_UNSPEC = 0,
    BPF_MAP_TYPE_HASH = 1,
    BPF_MAP_TYPE_ARRAY = 2,
    BPF_MAP_TYPE_PROG_ARRAY = 3,
    BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
    BPF_MAP_TYPE_PERCPU_HASH = 5,
    BPF_MAP_TYPE_PERCPU_ARRAY = 6,
    BPF_MAP_TYPE_STACK_TRACE = 7,
    BPF_MAP_TYPE_CGROUP_ARRAY = 8,
    BPF_MAP_TYPE_LRU_HASH = 9,
    BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
    BPF_MAP_TYPE_LPM_TRIE = 11,
    BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
    BPF_MAP_TYPE_HASH_OF_MAPS = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4,
    BPF_PROG_TYPE_TRACEPOINT = 5,
    BPF_PROG_TYPE_XDP = 6,
    BPF_PROG_TYPE_PERF_EVENT = 7,
    BPF_PROG_TYPE_CGROUP_SKB = 8,
    BPF_PROG_TYPE_CGROUP_SOCK = 9,
    BPF_PROG_TYPE_LWT_IN = 10,
    BPF_PROG_TYPE_LWT_OUT = 11,
    BPF_PROG_TYPE_LWT_XMIT = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_attach_type {
    BPF_CGROUP_INET_INGRESS = 0,
    BPF_CGROUP_INET_EGRESS = 1,
    BPF_CGROUP_INET_SOCK_CREATE = 2,
    __MAX_BPF_ATTACH_TYPE = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr {
    pub __bindgen_anon_1: __BindgenUnionField<bpf_attr__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<bpf_attr__bindgen_ty_2>,
    pub __bindgen_anon_3: __BindgenUnionField<bpf_attr__bindgen_ty_3>,
    pub __bindgen_anon_4: __BindgenUnionField<bpf_attr__bindgen_ty_4>,
    pub __bindgen_anon_5: __BindgenUnionField<bpf_attr__bindgen_ty_5>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_1 {
    pub map_type: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_1>() , 20usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . map_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( map_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . key_size as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( key_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . value_size
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( value_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . max_entries
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( max_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . map_flags as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( map_flags ) ));
}
impl Clone for bpf_attr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_2 {
    pub map_fd: __u32,
    pub key: __u64,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_2__bindgen_ty_1,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub value: __BindgenUnionField<__u64>,
    pub next_key: __BindgenUnionField<__u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               bpf_attr__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_2__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                bpf_attr__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2__bindgen_ty_1 ) )
                . value as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_attr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2__bindgen_ty_1 ) )
                . next_key as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_attr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                next_key ) ));
}
impl Clone for bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2 ) ) . map_fd as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_2
                ) , "::" , stringify ! ( map_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2 ) ) . key as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_2
                ) , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2 ) ) . flags as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_2
                ) , "::" , stringify ! ( flags ) ));
}
impl Clone for bpf_attr__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_3 {
    pub prog_type: __u32,
    pub insn_cnt: __u32,
    pub insns: __u64,
    pub license: __u64,
    pub log_level: __u32,
    pub log_size: __u32,
    pub log_buf: __u64,
    pub kern_version: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_3>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_3 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . prog_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( prog_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . insn_cnt as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( insn_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . insns as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( insns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . license as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( license ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . log_level as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( log_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . log_size as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( log_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . log_buf as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( log_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . kern_version
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( kern_version ) ));
}
impl Clone for bpf_attr__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_4 {
    pub pathname: __u64,
    pub bpf_fd: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_4>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_4 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_4 ) ) . pathname as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_4
                ) , "::" , stringify ! ( pathname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_4 ) ) . bpf_fd as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_4
                ) , "::" , stringify ! ( bpf_fd ) ));
}
impl Clone for bpf_attr__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_5 {
    pub target_fd: __u32,
    pub attach_bpf_fd: __u32,
    pub attach_type: __u32,
    pub attach_flags: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_5>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_5 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_5>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_5 ) ) . target_fd as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_5
                ) , "::" , stringify ! ( target_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_5 ) ) .
                attach_bpf_fd as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_5
                ) , "::" , stringify ! ( attach_bpf_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_5 ) ) . attach_type
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_5
                ) , "::" , stringify ! ( attach_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_5 ) ) . attach_flags
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_5
                ) , "::" , stringify ! ( attach_flags ) ));
}
impl Clone for bpf_attr__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_bpf_attr() {
    assert_eq!(::std::mem::size_of::<bpf_attr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( bpf_attr ) ));
    assert_eq! (::std::mem::align_of::<bpf_attr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_attr ) ));
}
impl Clone for bpf_attr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_func_id {
    BPF_FUNC_unspec = 0,
    BPF_FUNC_map_lookup_elem = 1,
    BPF_FUNC_map_update_elem = 2,
    BPF_FUNC_map_delete_elem = 3,
    BPF_FUNC_probe_read = 4,
    BPF_FUNC_ktime_get_ns = 5,
    BPF_FUNC_trace_printk = 6,
    BPF_FUNC_get_prandom_u32 = 7,
    BPF_FUNC_get_smp_processor_id = 8,
    BPF_FUNC_skb_store_bytes = 9,
    BPF_FUNC_l3_csum_replace = 10,
    BPF_FUNC_l4_csum_replace = 11,
    BPF_FUNC_tail_call = 12,
    BPF_FUNC_clone_redirect = 13,
    BPF_FUNC_get_current_pid_tgid = 14,
    BPF_FUNC_get_current_uid_gid = 15,
    BPF_FUNC_get_current_comm = 16,
    BPF_FUNC_get_cgroup_classid = 17,
    BPF_FUNC_skb_vlan_push = 18,
    BPF_FUNC_skb_vlan_pop = 19,
    BPF_FUNC_skb_get_tunnel_key = 20,
    BPF_FUNC_skb_set_tunnel_key = 21,
    BPF_FUNC_perf_event_read = 22,
    BPF_FUNC_redirect = 23,
    BPF_FUNC_get_route_realm = 24,
    BPF_FUNC_perf_event_output = 25,
    BPF_FUNC_skb_load_bytes = 26,
    BPF_FUNC_get_stackid = 27,
    BPF_FUNC_csum_diff = 28,
    BPF_FUNC_skb_get_tunnel_opt = 29,
    BPF_FUNC_skb_set_tunnel_opt = 30,
    BPF_FUNC_skb_change_proto = 31,
    BPF_FUNC_skb_change_type = 32,
    BPF_FUNC_skb_under_cgroup = 33,
    BPF_FUNC_get_hash_recalc = 34,
    BPF_FUNC_get_current_task = 35,
    BPF_FUNC_probe_write_user = 36,
    BPF_FUNC_current_task_under_cgroup = 37,
    BPF_FUNC_skb_change_tail = 38,
    BPF_FUNC_skb_pull_data = 39,
    BPF_FUNC_csum_update = 40,
    BPF_FUNC_set_hash_invalid = 41,
    BPF_FUNC_get_numa_node_id = 42,
    BPF_FUNC_skb_change_head = 43,
    BPF_FUNC_xdp_adjust_head = 44,
    __BPF_FUNC_MAX_ID = 45,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sk_buff {
    pub len: __u32,
    pub pkt_type: __u32,
    pub mark: __u32,
    pub queue_mapping: __u32,
    pub protocol: __u32,
    pub vlan_present: __u32,
    pub vlan_tci: __u32,
    pub vlan_proto: __u32,
    pub priority: __u32,
    pub ingress_ifindex: __u32,
    pub ifindex: __u32,
    pub tc_index: __u32,
    pub cb: [__u32; 5usize],
    pub hash: __u32,
    pub tc_classid: __u32,
    pub data: __u32,
    pub data_end: __u32,
}
#[test]
fn bindgen_test_layout___sk_buff() {
    assert_eq!(::std::mem::size_of::<__sk_buff>() , 84usize , concat ! (
               "Size of: " , stringify ! ( __sk_buff ) ));
    assert_eq! (::std::mem::align_of::<__sk_buff>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sk_buff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . len as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . pkt_type as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( pkt_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . mark as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( mark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . queue_mapping as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( queue_mapping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . protocol as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . vlan_present as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( vlan_present ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . vlan_tci as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( vlan_tci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . vlan_proto as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( vlan_proto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . priority as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . ingress_ifindex as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( ingress_ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . ifindex as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . tc_index as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( tc_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . cb as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . hash as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . tc_classid as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( tc_classid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . data as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . data_end as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( data_end ) ));
}
impl Clone for __sk_buff {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_tunnel_key {
    pub tunnel_id: __u32,
    pub __bindgen_anon_1: bpf_tunnel_key__bindgen_ty_1,
    pub tunnel_tos: __u8,
    pub tunnel_ttl: __u8,
    pub tunnel_ext: __u16,
    pub tunnel_label: __u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_tunnel_key__bindgen_ty_1 {
    pub remote_ipv4: __BindgenUnionField<__u32>,
    pub remote_ipv6: __BindgenUnionField<[__u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_bpf_tunnel_key__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<bpf_tunnel_key__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( bpf_tunnel_key__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<bpf_tunnel_key__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_tunnel_key__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key__bindgen_ty_1 ) ) .
                remote_ipv4 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_tunnel_key__bindgen_ty_1 ) , "::" , stringify ! (
                remote_ipv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key__bindgen_ty_1 ) ) .
                remote_ipv6 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_tunnel_key__bindgen_ty_1 ) , "::" , stringify ! (
                remote_ipv6 ) ));
}
impl Clone for bpf_tunnel_key__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_bpf_tunnel_key() {
    assert_eq!(::std::mem::size_of::<bpf_tunnel_key>() , 28usize , concat ! (
               "Size of: " , stringify ! ( bpf_tunnel_key ) ));
    assert_eq! (::std::mem::align_of::<bpf_tunnel_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_tunnel_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_tos as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_tos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_ttl as *
                const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_ttl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_ext as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_label as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_label ) ));
}
impl Clone for bpf_tunnel_key {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_ret_code { BPF_OK = 0, BPF_DROP = 2, BPF_REDIRECT = 7, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_sock {
    pub bound_dev_if: __u32,
    pub family: __u32,
    pub type_: __u32,
    pub protocol: __u32,
}
#[test]
fn bindgen_test_layout_bpf_sock() {
    assert_eq!(::std::mem::size_of::<bpf_sock>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bpf_sock ) ));
    assert_eq! (::std::mem::align_of::<bpf_sock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_sock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . bound_dev_if as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( bound_dev_if ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . family as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . protocol as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( protocol ) ));
}
impl Clone for bpf_sock {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xdp_action {
    XDP_ABORTED = 0,
    XDP_DROP = 1,
    XDP_PASS = 2,
    XDP_TX = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xdp_md {
    pub data: __u32,
    pub data_end: __u32,
}
#[test]
fn bindgen_test_layout_xdp_md() {
    assert_eq!(::std::mem::size_of::<xdp_md>() , 8usize , concat ! (
               "Size of: " , stringify ! ( xdp_md ) ));
    assert_eq! (::std::mem::align_of::<xdp_md>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( xdp_md ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xdp_md ) ) . data as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xdp_md ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xdp_md ) ) . data_end as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xdp_md ) , "::" ,
                stringify ! ( data_end ) ));
}
impl Clone for xdp_md {
    fn clone(&self) -> Self { *self }
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    //assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               //"Size of: " , stringify ! ( max_align_t ) ));
    // FIXME: For some reason bindgen generates 32, as above. 24 looks correct.
    assert_eq!(::std::mem::size_of::<max_align_t>() , 24usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn bpf_create_map(map_type: bpf_map_type,
                          key_size: ::std::os::raw::c_int,
                          value_size: ::std::os::raw::c_int,
                          max_entries: ::std::os::raw::c_int,
                          map_flags: __u32) -> ::std::os::raw::c_int;
}
#[cfg(kernelv412)]
extern "C" {
    pub fn bpf_create_map_in_map(map_type: bpf_map_type,
                                 key_size: ::std::os::raw::c_int,
                                 inner_map_fd: ::std::os::raw::c_int,
                                 max_entries: ::std::os::raw::c_int,
                                 map_flags: __u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_load_program(type_: bpf_prog_type, insns: *const bpf_insn,
                            insns_cnt: usize,
                            license: *const ::std::os::raw::c_char,
                            kern_version: __u32,
                            log_buf: *mut ::std::os::raw::c_char,
                            log_buf_sz: usize) -> ::std::os::raw::c_int;
}
#[cfg(kernelv412)]
extern "C" {
    pub fn bpf_verify_program(type_: bpf_prog_type, insns: *const bpf_insn,
                              insns_cnt: usize,
                              strict_alignment: ::std::os::raw::c_int,
                              license: *const ::std::os::raw::c_char,
                              kern_version: __u32,
                              log_buf: *mut ::std::os::raw::c_char,
                              log_buf_sz: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_map_update_elem(fd: ::std::os::raw::c_int,
                               key: *const ::std::os::raw::c_void,
                               value: *const ::std::os::raw::c_void,
                               flags: __u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_map_lookup_elem(fd: ::std::os::raw::c_int,
                               key: *const ::std::os::raw::c_void,
                               value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_map_delete_elem(fd: ::std::os::raw::c_int,
                               key: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_map_get_next_key(fd: ::std::os::raw::c_int,
                                key: *const ::std::os::raw::c_void,
                                next_key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_obj_pin(fd: ::std::os::raw::c_int,
                       pathname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_obj_get(pathname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_prog_attach(prog_fd: ::std::os::raw::c_int,
                           attachable_fd: ::std::os::raw::c_int,
                           type_: bpf_attach_type,
                           flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_prog_detach(attachable_fd: ::std::os::raw::c_int,
                           type_: bpf_attach_type) -> ::std::os::raw::c_int;
}
#[cfg(kernelv412)]
extern "C" {
    pub fn bpf_prog_test_run(prog_fd: ::std::os::raw::c_int,
                             repeat: ::std::os::raw::c_int,
                             data: *const ::std::os::raw::c_void, size: __u32,
                             data_out: *mut ::std::os::raw::c_void,
                             size_out: *mut __u32, retval: *mut __u32,
                             duration: *mut __u32) -> ::std::os::raw::c_int;
}
